---
layout: post
title: javaScript 学習履歴(同期／非同期　配列)
excerpt: javaScript、学習したこと(同期／非同期　配列)
date: 2020-08-26
tags: log, javascript
author: sasami
---


#わからないこと
.コールバックがやっぱりわからない
※一連の処理が終わるのを待って、処理をする

【JavaScript入門】プロトタイプ(prototype)の使い方と継承まとめ！
・Array.prototype
https://www.sejuku.net/blog/47722

【JavaScript】Object.assignを理解する
https://reffect.co.jp/html/javascript-object-assign

●Arrayオブジェクトにメソッドを追加した。
https://www.codewars.com/kata/525d50d2037b7acd6e000534





##今回はまったこと
↓の処理で、for文が時間かかるときに、その下のreturn trueが先に実行されてしまうのでは、と心配して、
コールバックや、Promise、async/awaitなどで、for文が終わってからreturn trueが実行されるようにしなければならないのではと思っていた。
-------------------------------
for(i=0;i<arr2.length; i++){
  console.log('i:' + i)
  if(arr1[i] !== arr2[i]){
    //console.log('違う数字あった');
    return false;
  }
}
//console.log('全部同じだったよ！');
return true;
-------------------------------
                       
##今回分かったこと
そもそもjavascriptはシングルスレッドで同期処理の言語なので、
普通の処理を順番に実行させたければ特別callbackやPromisやらasync/awaitなどを考える必要はなかった。
                       
では、どういったときにcallbackやPromisやらasync/awaitなどが必要になるのか？


■同期処理...プログラムが記述された通りに実行されるもの
                       
■非同期処理...処理が実行できるようになるのを待ち，実行できるようになってから実行するといった処理
EX)イベント処理や、setTimeout()、setInterval()、promiseなど
                       
>※JavaScriptのプログラムはシングルスレッドにおいて、関数単位で実行される
>基本的にはJavaScriptはシングルスレッドの実装しかできません。
>非同期処理を実装せずにプログラムを書くとメインプログラムが単一スレッドを独占してしまいます。
>非同期処理を実装すると，実行を待っている関数待ちの行列にコールバック関数が割り込みされます。
>イベント処理なども発火してすぐにコールバックが実行されるのではなく、実行中の関数が実行終わってから実行されるようです。(処理は関数単位で実行される)
>
>【JavaScriptの非同期処理を並列処理と勘違いしていませんか？】
>https://qiita.com/klme_u6/items/ea155f82cbe44d6f5d88
  
  
■並列処理...マルチスレッドでプログラムを実行し計算負荷を分散させる処理
※JavaScriptでマルチスレッドを実行するにはWebWorkersというAPIを使うと実装できる
                       
■並行処理...あくまでシングルスレッドで、処理を順不同に行う処理
※人間にとってみればあたかも同時に行われているように見えてしまう処理
JavaScriptの非同期処理、イベント処理やpromise等は並行処理に当たる


>JavaScriptインタプリタはシングルスレッドで動くので、2つ以上の処理を同時に実行できません。
>しかし、非同期処理の仕組みは「処理Aの完了を待たずして、処理Aの実行は継続しつつ次の処理Bに進む」といったものでした。
>これでは処理Aの実行と処理Bの実行が同時に起こってしまい、シングルスレッドでは処理しきれなくなってしまうはずです。
>JavaScriptインタプリタは、このような問題を同期関数・非同期関数とキュー・スタックを使ったモデルによって解決しています。
>
>【JavaScriptの非同期処理をできる限り正確に理解する】
>https://qiita.com/UTDoi/items/d49ea919818d9b519f93          


>■キュー・スタックとは
>キューとスタックは、データ構造の1種です。
>データ構造とは、データの出し入れの方法のことです。
>
>キューにデータを入れると、データを入れた順番通りに、データが取り出されます。
>一方スタックにデータを入れると、データを入れた順番と逆順に、データが取り出されます。
>                       
>JavaScriptにおける関数の中には、WebAPIを使用して処理を行う特殊なものがあります。
>たとえば、setInterval関数やsetTimeout関数はTimerAPIを使い、addEventListenerなどのイベント系関数はDOMAPIを使います。
>
>これらの関数は、与えられた処理内容を外部のWebAPIにいわば投げてしまいます。
>外部WebAPIに「これをやってくれ！」と頼んだあとは、関数としては実行終了してしまい、コールスタックから取り除かれてJavaScriptインタプリタは次の関数の実行を進めていきます。
>JavaScriptインタプリタがどんどん次の関数を実行している間にも、処理を任せられたWebAPIの方は独自に処理を実行し続けています。
>これらの関数は、実行時点で引数にコールバック関数を取ることが多いかと思います。
>WebAPIの方で処理が完了した時、指定しておいたコールバック関数はタスクキューに追加されます。
>そして、コールスタックの中身が空になった（コード上の全ての関数を実行しおわった）とき、イベントループによってタスクキューに登録されている関数がコールスタック上に追加され、実行されます。
>
>このように、処理をWebAPIに任せる関数を使うことで「2つ以上の処理を同時に進め、処理が完了したタイミングで指定した処理を実行する」非同期処理が実現できます。
>JavaScriptはシングルスレッドなので、別のスレッドを立ててマルチスレッド的に並列処理をしているわけではなく、
>WebAPIさんという「他の人」に代わりに処理を実行してもらうことで擬似的に並行処理を行なっているのがわかるかと思います。
>
>このような動作をする特殊な関数たちを、非同期関数と呼ぶことにします。
>逆にJavaScriptの世界の中だけで処理を実行し、１つの処理が終わるまでは次の処理を進めることができないような普通の関数を、同期関数と呼ぶことにします。
>
>■同期関数のみの場合
>同期関数しかコード上にない場合は、基本的に以下のように処理されていきます。
>
>1.コードが上から順番に実行されていきます。
>2.同期関数（関数Aと呼ぶ）が呼び出されているコードを発見すると、一旦止まって（ここでいう「止まる」とはコードを１行ずつ実行していくのを止めるということです）関数Aをコールスタックに追加します。
>3.関数Aの中のコードを1行ずつ実行していきます。
>4.関数Aの中のコードでまた同期関数（関数Bと呼ぶ）の呼び出しを発見したら（いわゆるコールバック関数などが存在する時です）また一旦止まって関数Bをコールスタックに追加します。
>5.関数Bの中のコードを1行ずつ実行します。
>6.関数Bの中のコードを全て実行し終えると、コールスタックから関数Bを削除して関数Aの中のコードに戻ります。
>7.関数Aの続きのコードを実行していきます。
>8.関数Aの中のコードを全て実行し終えると、コールスタックから関数Aを削除します。
>9.コールスタックの中身が空になると、次の行のコードの実行に進みます。
>
>ここでスタックの特徴通り、関数A→関数Bの順にコールスタックに追加されたのに、削除されるのは関数B→関数Aの順番になっていることがわかります。
>
>このコールスタック、無限に関数を積み重ねることはできません。何事にも限界はあります。
>コールスタックの許容量を超えてしまうことをスタックオーバーフローといい、エラーになってしまいます。
  
  
>■非同期関数が含まれる場合
>非同期関数も普通にコールスタックに追加され、中身が実行されます。
>しかし、先ほども述べたように非同期関数は処理の内容をWebAPIに任せ、そこで実行が行われるのでした。
>
>WebAPIの処理が完了した時、コールバック関数はタスクキューに追加されます。
>コールスタックが空になった時、イベントループによってタスクキューに登録された関数が登録された順に取り出され、コールスタックの中に突っ込みまれます。
>あとは通常通り関数が実行され、コールスタックから取り除かれる流れが始まります。
>
>以下のような流れで処理されていきます。
>1.コードが上から順番に実行されていきます。
>2.非同期関数（関数Aと呼ぶ）が呼び出されているコードを発見、関数Aをコールスタックに追加します。
>3.関数Aの中のコードを実行した結果、WebAPIに処理を任せるように書いてあるのでWebAPIに処理の内容を投げます。
>4.コールスタックから関数Aを削除し、次の行のコードに移ります。
>5.同期関数（関数Bと呼ぶ）が呼び出されているコードを発見、関数Bをコールスタックに追加します。
>6.関数B内のコードを実行していきます。
>7.同時にWebAPIの方でも処理が完了していたようです。コールバック関数（CB1と呼ぶ）がタスクキューに登録されます。
>8.関数Bが実行完了したので、コールスタックから関数Bを削除し、次の行のコードに進みます。
>9.非同期関数（関数Cと呼ぶ）が呼び出されているコードを発見、関数Cをコールスタックに追加します。
>10.関数Cの中のコードを実行した結果、WebAPIに処理を任せるように書いてあるのでWebAPIに処理の内容を投げます。
>11.コールスタックから関数Cを削除し、次の行のコードに移ります。
>12.同期関数（関数Dと呼ぶ）が呼び出されているコードを発見、関数Dをコールスタックに追加します。
>13.関数D内のコードを実行していきます。
>14.関数Dが実行完了したので、コールスタックから関数Dを削除し、次の行のコードに進みます。
>15.同期関数（関数Eと呼ぶ）が呼び出されているコードを発見、関数Eをコールスタックに追加します。
>16.同時にWebAPIの方でも処理が完了していたようです。コールバック関数（CB2と呼ぶ）がタスクキューに登録されます。
>17.関数E内のコードを実行していきます。
>18.関数Eが実行完了したので、コールスタックから関数Eを削除し、次の行のコードに進みます。
>19.コールスタックの中身が空になりコードも全て読み終わったので、イベントループによってタスクキューの中のCB1がコールスタックに追加されます。
>20.CB1の中のコードが実行されます。完了後、コールスタックから削除されます。
>21.コールスタックの中身が空になりコードも全て読み終わったので、イベントループによってタスクキューの中のCB2がコールスタックに追加されます。
>22.CB2の中のコードが実行されます。完了後、コールスタックから削除されます。
>23.コールスタックもタスクキューも空なので、一旦処理終了です。 具体例に関してはテキストで表すには複雑すぎるので書きません。
>
>■setTimeout()
>------------------
>setTimeout(function(){console.log("setTimeoutの中の人です")}, 1000);
>console.log("Hello");
>------------------
>setTimeout(function(){console.log("setTimeoutの中の人です")}, 0);
>console.log("Hello");
>------------------
>↓
>実行結果はいずれも以下になります。
>------------------
> Hello
> setTimeoutの中の人です
>------------------
>
>setTimeout(function(){},1000)
>の意味は「1秒後にfunction()を実行する」ではありません。
>正確には「1秒後にタスクキューにfunction()を登録する」なのです。
>
>setTimeoutが非同期処理を行う関数なので、タスクキューに登録されたコールバック関数は、「JavaScriptのコードが全て実行され、コールスタックの中身が空になった時」に初めてイベントループによってコールスタックに追加されます。
>そのため、確かにsetTimeoutが実行されるとすぐさまタスクキューにコールバック関数は登録されますが、一旦console.log("Hello");が読み取られ、実行されてコールスタックから取り除かれるのを待ってから実行されることになります。
>
>【JavaScriptの非同期処理をできる限り正確に理解する】
>https://qiita.com/UTDoi/items/d49ea919818d9b519f93
                       

--------------------------------------------------------------------------------
#新しく知ったこと
##整数かどうか判定
Number.isInteger(判定する値); -> true/false

##配列かどうか判定
Array.isArray(判定する値); -> true/false

##String.match(正規表現);
文字列中の正規表現にマッチする文字を配列として返す。
>const paragraph = 'The quick brown fox jumps over the lazy dog. It barked.';
>const regex = /[A-Z]/gi;
>const found = paragraph.match(regex);
>// ["T", "h", "e", "q", "u", "i", "c", "k", "b", "r", "o", "w", "n", "f", "o", "x", "j", "u", "m", "p", "s", "o", "v", "e", "r", "t", "h", "e", "l", "a", "z", "y", "d", "o", "g", "I", "t", "b", "a", "r", "k", "e", "d"]

##Array.reverse();
配列の要素を逆順にする。
  
##Array.map()
map() メソッドは、与えられた関数を配列のすべての要素に対して呼び出し、その結果からなる新しい配列を生成する。
>const array1 = [1, 4, 9, 16];
>const map1 = array1.map(x => x * 2);
  
>配列データ.map( function( value, index, array ) {
>  //処理
>});  
「value」は、配列の値、「index」は、配列のインデックス番号、「array」は、現在処理している配列

##Array.join( separator );
配列を連結して文字列を返す。
>['a','i','u'].join('');//aiu

例題）
https://www.codewars.com/kata/54b42f9314d9229fd6000d9c/javascript
  
>function duplicateEncode(word){
>  return word
>    .toLowerCase()　//文字列を小文字に変換して
>    .split('')　//配列に変換して
>    .map( function (a, i, w) {
>      return w.indexOf(a) == w.lastIndexOf(a) ? '(' : ')'  //配列【w】中で、各要素【a】が最初に現れる位置【w.indexOf(a)】と、最後に現れる位置【w.lastIndexOf(a)】が同じなら'('、異なれば')'に配列を置き換える。
>    })
>    .join(''); //要素を'('か')'に置き換えた配列を連結して文字列にする。
>}

##Array.reduce();
reduce()は対象となる配列に対して任意の関数を実行することができます。
第1引数の「累積値」には、配列要素を順番に処理していった値が格納されています。
第2引数の「要素」は現在処理されている配列要素です。
この関数内で「return」を使い、任意の処理を返すことで累積値に結果が保持されて最終的に1つの値となって取得できるわけです。

例）配列の各要素をすべて合計した値を取得。
------------------------
Array.reduce(function(累積値, 要素) {
  return 累積値 + 要素
});
------------------------
例）配列の各要素でペアのない値を取得する。（ペアがない値は一つだけの前提条件あり）
------------------------
let arr = [20,1,-1,2,-2,3,3,5,5,1,2,4,20,4,-1,-2,5];
const findOdd = (arr) => {
	return arr.reduce((a, b) => {
		return a ^ b;//「^」ビット毎 XOR
	});
};
------------------------
##「^」ビット毎 XOR
ビット毎 XOR 演算子 (^) は、両方のオペランドの対応するビットの一方だけが1である位置のビットで1を返します。
⇒ビット毎 XOR 演算子 (^)では、同じ数どうしを計算すると0になるので、上記の例題では計算が終了したときに、ペアの存在しない値分だけが返される。

##Array.filter()
filter() メソッドは、与えられた関数によって実装されたテストに合格したすべての配列からなる新しい配列を生成します。
>const printNo1 = ["aaa","bbb","","ccc","","ddd"]
>const printNo2 = printNo1.filter(word => word !== "");//空文字を削除して新しい配列を作る
  
>function filter_list(l) {
>  return l.filter(w => typeof w === 'number');//要素の型が数値の文字だけ返して新しい配列を作る
>}
  
  
##Array.every
everyは配列が条件をすべて満たす場合にtrueを返す
>const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>arr.every(value => value > 0) -> true
>arr.every(value => value < 5) -> false

##Array.some
someは配列が条件を一つでも満たしていればtrueを返す
>const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>arr.some(value => value < 10) -> true
>arr.every(value => value > 11) -> false

##Math.sqrt(val)
sqrt関数は平方根を計算した結果を返します。
>var num = Math.sqrt(9); -> num = 3


##sort関数
sort関数のデフォルトでは要素を文字列に変換して文字コード順に並び替える。
※文字と数字が混在する場合、「数字→ローマ字→日本語」の順となる。
>var array = [1975,11,20];
>array.sort();

###数値の昇順・降順でソートするには
sort関数は引数に関数を指定でき、関数でソートのルールを定義できる。
関数を指定すると、配列の要素2つを取り出して関数に引数として渡してソートする。

関数の戻り値が正の時　→　引数1を引数2の後ろに並べ替え。
関数の戻り値が負の時　→　引数1を引数2の前に並べ替え。
関数の戻り値が0の時　→　何もしない。

>var a = [33, 4, 1111, 222];
>a.sort(function(a,b){  // 4, 33, 222, 1111（数値順）
>    return a-b;        // a > bなら正の数、a == bなら0、a < bなら負の数が返る
>});

##配列名.shift()
配列の先頭から要素を取り出して、配列からは削除する

##配列名.pop()
配列の末尾から要素を取り出して、配列からは削除する

##Array.splice()
既存の要素を取り除いたり、置き換えたり、新しい要素を追加したりすることで、配列の内容を変更します。
https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
>exam)
>###index 3 の位置 (4番目の要素) から一つ取り除く
>let myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon']
>let removed = myFish.splice(3, 1)
>// removed は ["mandarin"]
>// myFish は ["angel", "clown", "drum", "sturgeon"]

  
##Array.slice();
配列を分割する方法
>let array = ['1番目', '2番目', '3番目', '4番目', '5番目'];
>let array2 = array.slice(2);  //3番目から最後まで
>let array3 = array.slice(2,4);//3番目から4番目まで
>let array4 = array.slice(); //全部

  
#配列のコピーについて
JavaScriptで注意が必要なことの１つが配列やオブジェクトのコピーです。
配列をコピーする場合、配列を別の変数にそのまま代入することはNGです。
###NG例
>var original = ['A', 'B', 'C'];
>var cloned = original;
この場合、clonedの内容を書き換えた場合でも、originalの内容も変更されてしまいます。
>cloned[2] = 'Z';
>console.log(original); //['A', 'B', 'Z']
>console.log(cloned); //['A', 'B', 'Z']

普通の数値などの変数の場合、別変数に代入すれば完全に別物として扱われます。
しかし配列（あるいはオブジェクト）の場合は
・深い（ディープ）コピー【Deep Copy】
・浅い（シャロー）コピー【Shallow Copy】
の２種類があります。
シャローコピーの場合はオリジナル配列とクローン配列は
同じ参照（データのある場所）を共有しているため
一方を変更すればもう一方も変更されてしまいます。
  
【JavaScriptで配列をコピーする”本当に”正しい方法】
https://pisuke-code.com/js-correct-way-of-array-copy/


※今回、配列のコピーには、Array.slice(0)を使用した。
【配列の指定した範囲の要素をコピーして新しい配列を作成する】
https://www.javadrive.jp/javascript/array/index14.html

他にも、配列をコピーする方法は、
Array.from、[...array]、array.concat()、JSON.parse(JSON.stringify(array))、
など複数あるらしく、また、元の配列には反映させないが、
厳密にはDeep Copyではない、など、いろいろあるらしいがまだ未整理。
  
【Javascript配列のコピー方法(Deep/Shallow/代入)備忘録】
https://qiita.com/tomson/items/2138a9aa2ae244686197

  
  
  
  
