---
layout: post
title: javaScript 学習履歴
excerpt: javaScript、学習したこと
date: 2020-08-26
tags: log, javascript
author: sasami
---


#わからないこと
.コールバックがやっぱりわからない
※一連の処理が終わるのを待って、処理をする

##今回はまったこと
↓の処理で、for文が時間かかるときに、その下のreturn trueが先に実行されてしまうのでは、と心配して、
コールバックや、Promise、async/awaitなどで、for文が終わってからreturn trueが実行されるようにしなければならないのではと思っていた。
-------------------------------
for(i=0;i<arr2.length; i++){
  console.log('i:' + i)
  if(arr1[i] !== arr2[i]){
    //console.log('違う数字あった');
    return false;
  }
}
//console.log('全部同じだったよ！');
return true;
-------------------------------
                       
##今回分かったこと
そもそもjavascriptはシングルスレッドで同期処理の言語なので、
普通の処理を順番に実行させたければ特別callbackやPromisやらasync/awaitなどを考える必要はなかった。
                       
では、どういったときにcallbackやPromisやらasync/awaitなどが必要になるのか？


■同期処理...プログラムが記述された通りに実行されるもの
                       
■非同期処理...処理が実行できるようになるのを待ち，実行できるようになってから実行するといった処理
EX)イベント処理や、setTimeout()、setInterval()、promiseなど
                       
>※JavaScriptのプログラムはシングルスレッドにおいて、関数単位で実行される
>基本的にはJavaScriptはシングルスレッドの実装しかできません。
>非同期処理を実装せずにプログラムを書くとメインプログラムが単一スレッドを独占してしまいます。
>非同期処理を実装すると，実行を待っている関数待ちの行列にコールバック関数が割り込みされます。
>イベント処理なども発火してすぐにコールバックが実行されるのではなく、実行中の関数が実行終わってから実行されるようです。(処理は関数単位で実行される)
>
>【JavaScriptの非同期処理を並列処理と勘違いしていませんか？】
>https://qiita.com/klme_u6/items/ea155f82cbe44d6f5d88
  
  
■並列処理...マルチスレッドでプログラムを実行し計算負荷を分散させる処理
※JavaScriptでマルチスレッドを実行するにはWebWorkersというAPIを使うと実装できる
                       
■並行処理...あくまでシングルスレッドで、処理を順不同に行う処理
※人間にとってみればあたかも同時に行われているように見えてしまう処理
JavaScriptの非同期処理、イベント処理やpromise等は並行処理に当たる


>JavaScriptインタプリタはシングルスレッドで動くので、2つ以上の処理を同時に実行できません。
>しかし、非同期処理の仕組みは「処理Aの完了を待たずして、処理Aの実行は継続しつつ次の処理Bに進む」といったものでした。
>これでは処理Aの実行と処理Bの実行が同時に起こってしまい、シングルスレッドでは処理しきれなくなってしまうはずです。
>JavaScriptインタプリタは、このような問題を同期関数・非同期関数とキュー・スタックを使ったモデルによって解決しています。
>
>【JavaScriptの非同期処理をできる限り正確に理解する】
>https://qiita.com/UTDoi/items/d49ea919818d9b519f93          


>■キュー・スタックとは
>キューとスタックは、データ構造の1種です。
>データ構造とは、データの出し入れの方法のことです。
>
>キューにデータを入れると、データを入れた順番通りに、データが取り出されます。
>一方スタックにデータを入れると、データを入れた順番と逆順に、データが取り出されます。
>                       
>JavaScriptにおける関数の中には、WebAPIを使用して処理を行う特殊なものがあります。
>たとえば、setInterval関数やsetTimeout関数はTimerAPIを使い、addEventListenerなどのイベント系関数はDOMAPIを使います。
>
>これらの関数は、与えられた処理内容を外部のWebAPIにいわば投げてしまいます。
>外部WebAPIに「これをやってくれ！」と頼んだあとは、関数としては実行終了してしまい、コールスタックから取り除かれてJavaScriptインタプリタは次の関数の実行を進めていきます。
>JavaScriptインタプリタがどんどん次の関数を実行している間にも、処理を任せられたWebAPIの方は独自に処理を実行し続けています。
>これらの関数は、実行時点で引数にコールバック関数を取ることが多いかと思います。
>WebAPIの方で処理が完了した時、指定しておいたコールバック関数はタスクキューに追加されます。
>そして、コールスタックの中身が空になった（コード上の全ての関数を実行しおわった）とき、イベントループによってタスクキューに登録されている関数がコールスタック上に追加され、実行されます。
>
>このように、処理をWebAPIに任せる関数を使うことで「2つ以上の処理を同時に進め、処理が完了したタイミングで指定した処理を実行する」非同期処理が実現できます。
>JavaScriptはシングルスレッドなので、別のスレッドを立ててマルチスレッド的に並列処理をしているわけではなく、
>WebAPIさんという「他の人」に代わりに処理を実行してもらうことで擬似的に並行処理を行なっているのがわかるかと思います。
>
>このような動作をする特殊な関数たちを、非同期関数と呼ぶことにします。
>逆にJavaScriptの世界の中だけで処理を実行し、１つの処理が終わるまでは次の処理を進めることができないような普通の関数を、同期関数と呼ぶことにします。
>
>■同期関数のみの場合
>同期関数しかコード上にない場合は、基本的に以下のように処理されていきます。
>
>1.コードが上から順番に実行されていきます。
>2.同期関数（関数Aと呼ぶ）が呼び出されているコードを発見すると、一旦止まって（ここでいう「止まる」とはコードを１行ずつ実行していくのを止めるということです）関数Aをコールスタックに追加します。
>3.関数Aの中のコードを1行ずつ実行していきます。
>4.関数Aの中のコードでまた同期関数（関数Bと呼ぶ）の呼び出しを発見したら（いわゆるコールバック関数などが存在する時です）また一旦止まって関数Bをコールスタックに追加します。
>5.関数Bの中のコードを1行ずつ実行します。
>6.関数Bの中のコードを全て実行し終えると、コールスタックから関数Bを削除して関数Aの中のコードに戻ります。
>7.関数Aの続きのコードを実行していきます。
>8.関数Aの中のコードを全て実行し終えると、コールスタックから関数Aを削除します。
>9.コールスタックの中身が空になると、次の行のコードの実行に進みます。
>
>ここでスタックの特徴通り、関数A→関数Bの順にコールスタックに追加されたのに、削除されるのは関数B→関数Aの順番になっていることがわかります。
>
>このコールスタック、無限に関数を積み重ねることはできません。何事にも限界はあります。
>コールスタックの許容量を超えてしまうことをスタックオーバーフローといい、エラーになってしまいます。
  
  
>■非同期関数が含まれる場合
>非同期関数も普通にコールスタックに追加され、中身が実行されます。
>しかし、先ほども述べたように非同期関数は処理の内容をWebAPIに任せ、そこで実行が行われるのでした。
>
>WebAPIの処理が完了した時、コールバック関数はタスクキューに追加されます。
>コールスタックが空になった時、イベントループによってタスクキューに登録された関数が登録された順に取り出され、コールスタックの中に突っ込みまれます。
>あとは通常通り関数が実行され、コールスタックから取り除かれる流れが始まります。
>
>以下のような流れで処理されていきます。
>1.コードが上から順番に実行されていきます。
>2.非同期関数（関数Aと呼ぶ）が呼び出されているコードを発見、関数Aをコールスタックに追加します。
>3.関数Aの中のコードを実行した結果、WebAPIに処理を任せるように書いてあるのでWebAPIに処理の内容を投げます。
>4.コールスタックから関数Aを削除し、次の行のコードに移ります。
>5.同期関数（関数Bと呼ぶ）が呼び出されているコードを発見、関数Bをコールスタックに追加します。
>6.関数B内のコードを実行していきます。
>7.同時にWebAPIの方でも処理が完了していたようです。コールバック関数（CB1と呼ぶ）がタスクキューに登録されます。
>8.関数Bが実行完了したので、コールスタックから関数Bを削除し、次の行のコードに進みます。
>9.非同期関数（関数Cと呼ぶ）が呼び出されているコードを発見、関数Cをコールスタックに追加します。
>10.関数Cの中のコードを実行した結果、WebAPIに処理を任せるように書いてあるのでWebAPIに処理の内容を投げます。
>11.コールスタックから関数Cを削除し、次の行のコードに移ります。
>12.同期関数（関数Dと呼ぶ）が呼び出されているコードを発見、関数Dをコールスタックに追加します。
>13.関数D内のコードを実行していきます。
>14.関数Dが実行完了したので、コールスタックから関数Dを削除し、次の行のコードに進みます。
>15.同期関数（関数Eと呼ぶ）が呼び出されているコードを発見、関数Eをコールスタックに追加します。
>16.同時にWebAPIの方でも処理が完了していたようです。コールバック関数（CB2と呼ぶ）がタスクキューに登録されます。
>17.関数E内のコードを実行していきます。
>18.関数Eが実行完了したので、コールスタックから関数Eを削除し、次の行のコードに進みます。
>19.コールスタックの中身が空になりコードも全て読み終わったので、イベントループによってタスクキューの中のCB1がコールスタックに追加されます。
>20.CB1の中のコードが実行されます。完了後、コールスタックから削除されます。
>21.コールスタックの中身が空になりコードも全て読み終わったので、イベントループによってタスクキューの中のCB2がコールスタックに追加されます。
>22.CB2の中のコードが実行されます。完了後、コールスタックから削除されます。
>23.コールスタックもタスクキューも空なので、一旦処理終了です。 具体例に関してはテキストで表すには複雑すぎるので書きません。
>
>【JavaScriptの非同期処理をできる限り正確に理解する】
>https://qiita.com/UTDoi/items/d49ea919818d9b519f93
                       

--------------------------------------------------------------------------------
#新しく知ったこと
##整数かどうか判定
Number.isInteger(判定する値); -> true/false

##配列かどうか判定
Array.isArray(判定する値); -> true/false

##Array.map()
map() メソッドは、与えられた関数を配列のすべての要素に対して呼び出し、その結果からなる新しい配列を生成する。
>const array1 = [1, 4, 9, 16];
>const map1 = array1.map(x => x * 2);

##Array.filter()
filter() メソッドは、与えられた関数によって実装されたテストに合格したすべての配列からなる新しい配列を生成します。
>const printNo1 = ["aaa","bbb","","ccc","","ddd"]
>const printNo2 = printNo1.filter(word => word !== "");//空文字を削除して新しい配列を作る
  
##Array.every
everyは配列が条件をすべて満たす場合にtrueを返す
>const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>arr.every(value => value > 0) -> true
>arr.every(value => value < 5) -> false

##Array.some
someは配列が条件を一つでも満たしていればtrueを返す
>const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>arr.some(value => value < 10) -> true
>arr.every(value => value > 11) -> false

##Math.sqrt(val)
sqrt関数は平方根を計算した結果を返します。
>var num = Math.sqrt(9); -> num = 3


##sort関数
sort関数のデフォルトでは要素を文字列に変換して文字コード順に並び替える。
※文字と数字が混在する場合、「数字→ローマ字→日本語」の順となる。
>var array = [1975,11,20];
>array.sort();

###数値の昇順・降順でソートするには
sort関数は引数に関数を指定でき、関数でソートのルールを定義できる。
関数を指定すると、配列の要素2つを取り出して関数に引数として渡してソートする。

関数の戻り値が正の時　→　引数1を引数2の後ろに並べ替え。
関数の戻り値が負の時　→　引数1を引数2の前に並べ替え。
関数の戻り値が0の時　→　何もしない。

>var a = [33, 4, 1111, 222];
>a.sort(function(a,b){  // 4, 33, 222, 1111（数値順）
>    return a-b;        // a > bなら正の数、a == bなら0、a < bなら負の数が返る
>});

##配列名.shift()
配列の先頭から要素を取り出して、配列からは削除する

##配列名.pop()
配列の末尾から要素を取り出して、配列からは削除する




##Array.slice();
配列を分割する方法
>let array = ['1番目', '2番目', '3番目', '4番目', '5番目'];
>let array2 = array.slice(2);  //3番目から最後まで
>let array3 = array.slice(2,4);//3番目から4番目まで
>let array4 = array.slice(); //全部
